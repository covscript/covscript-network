package netutils

import network.*, regex, curl

constant server_name = "CovScript-NetUtils"
constant server_version = "1.1.3"

# Internal Functions

var request_line_reg = regex.build("^([A-Z]+) ([^ ?]+)(?:\\?([^ ]*))? HTTP/([0-9.]+)$")
var request_header_reg = regex.build("^([^:]*): ?(.*)$")

namespace state_codes
    constant code_200 = "200 OK"
    constant code_400 = "400 Bad Request"
    constant code_403 = "403 Forbidden"
    constant code_404 = "404 Not Found"
    constant code_408 = "408 Request Timeout"
    constant code_500 = "500 Internal Server Error"
    constant code_503 = "503 Service Unavailable"
end

var wday_map = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
}

var mon_map = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
}

function time_padding(obj, width)
    var time = to_string(obj)
    var last = width - time.size
    if last <= 0
        return time
    end
    var str = new string
    foreach it in range(last) do str.append("0")
    return str + time
end

function compose_http_time()
    var tm = runtime.utc_time()
    return wday_map[tm.wday] + ", " +
        time_padding(tm.mday, 2) + " " +
        mon_map[tm.mon] + " " +
        to_string(1900 + tm.year) + " " +
        time_padding(tm.hour, 2) + ":" +
        time_padding(tm.min, 2) + ":" +
        time_padding(tm.sec, 2) + " GMT"
end

function compose_response(code)
    return "HTTP/1.1 " + code + "\r\n" +
        "Connection: close\r\n" +
        "Content-Length: 0\r\n\r\n"
end

var log_stream = null

function log(msg)
    if log_stream != null
        log_stream.println("[" + compose_http_time() + "]: " + msg)
    end
end

function async_send(sock, resp)
    if !sock.is_open()
        return
    end
    var state = async.write(sock, resp)
    if !state.wait()
        log("Send error: " + state.get_error())
    end
end

function read_file(path)
    var start_time = runtime.time()
    var ifs = iostream.fstream(path, iostream.openmode.bin_in)
    var data = new iostream.char_buff
    var ofs = data.get_ostream()
    loop
        var ch = ifs.get()
        if ifs.good() && !ifs.eof()
            ofs.put(ch)
        else
            break
        end
        if runtime.time() - start_time > 100
            fiber.yield()
            start_time = runtime.time()
        end
    end
    return data.get_string()
end

function path_normalize(path)
    if path == null || path.empty()
        return "."
    end
    var alt_sep = (system.path.separator == '/' ? '\\' : '/')
    var is_unc = false
    var is_abs = false
    var drive_letter = ""
    var norm_path = new string
    foreach ch in path
        if ch == alt_sep
            norm_path.append('/')
        else
            norm_path.append(ch)
        end
    end
    context.unlink_var("path")
    path = norm_path
    if system.path.separator == '\\'
        if path.find("//", 0) == 0  # UNC Path
            is_unc = true
            path = path.substr(2, path.size - 2)
        else
            var m = regex.build("^([A-Za-z]:)").match(path)
            if !m.empty()
                drive_letter = m.str(1)
                path = path.substr(drive_letter.size, path.size - drive_letter.size)
                is_abs = true
            end
        end
        is_abs = is_abs or is_unc
    else
        if path.find("/", 0) == 0
            is_abs = true
        end
    end
    var components = path.split({'/'})
    var stack = new array
    foreach comp in components
        if comp.empty() or comp == "."
            continue
        end
        if comp == ".."
            if stack.size > 0 and stack.back != ".."
                stack.pop_back()
            else
                if !is_abs
                    stack.push_back("..")
                end
            end
        else
            stack.push_back(comp)
        end
    end
    var result = new string
    if is_unc
        result = "//"
    else if drive_letter != ""
        result = drive_letter
    else if is_abs
        result = "/"
    end
    foreach comp in stack
        if !result.empty() and result[-1] != '/'
            result.append("/")
        end
        result.append(comp)
    end
    return result
end

var mime_map = {
    ".html": "text/html",
    ".htm": "text/html",
    ".txt": "text/plain",
    ".js": "application/javascript",
    ".css": "text/css",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".json": "application/json"
} as hash_map

function get_mime(path)
    var pos = path.rfind(".", path.size - 1)
    if pos == -1
        return "application/octet-stream"
    end
    var ext = path.substr(pos, path.size - pos).tolower()
    if mime_map.exist(ext)
        return mime_map[ext]
    else
        return "application/octet-stream"
    end
end

class http_session
    var url = null
    var args = null
    var sock = null
    var host = null
    var method = null
    var version = null
    var connection = null
    var content_length = null
    function construct(socket, request_header)
        sock = socket
        var request_line = request_header.front
        request_header.pop_front()
        var match = request_line_reg.match(request_line)
        if !match.empty()
            method = match.str(1)
            url = match.str(2)
            args = match.str(3)
            version = match.str(4)
        else
            async_send(sock, compose_response(state_codes.code_400))
            return
        end
        if url.empty()
            url = "/"
        end
        foreach line in request_header
            var match = request_header_reg.match(line)
            if !match.empty()
                switch match.str(1).tolower()
                    case "host"
                        host = match.str(2)
                    end
                    case "connection"
                        connection = match.str(2)
                    end
                    case "content-length"
                        content_length = match.str(2).to_number()
                    end
                end
            end
        end
    end
    function send_response(code, data, type)
        var conn = connection
        if conn == null || conn.empty()
            conn = (version <= "1.0" ? "close" : "keep-alive")
        end
        var content_len = to_string(data.size)
        var resp = new string
        resp.append("HTTP/" + version + " " + code + "\r\n")
        resp.append("Date: " + compose_http_time() + "\r\n")
        resp.append("Server: " + server_name + "/" + server_version + "\r\n")
        resp.append("Connection: " + conn + "\r\n")
        resp.append("Content-Length: " + content_len + "\r\n")
        resp.append("Content-Type: " + type + "\r\n")
        resp.append("\r\n")
        resp.append(data)
        async_send(sock, resp)
    end
end

# Workers

struct worker_type
    var co = null
    # 0 = init, 1 = wait, 2 = busy
    var state = 0
    var server = null
end

function wait_sock(sock, size)
    while sock.available() < size
        fiber.yield()
    end
end

function trim(str)
    var beg = 0
    var end = str.size - 1
    while beg <= end && str[beg].isspace()
        ++beg
    end
    while end >= beg && str[end].isspace()
        --end
    end
    if beg > end
        return ""
    end
    return str.substr(beg, end - beg + 1)
end

function worker_main(self)
    loop
        self->state = 1
        # Accept new connection
        var sock = new tcp.socket
        var state = async.accept(sock, self->server->acceptor)
        if !state.wait()
            log("Accept error: " + state.get_error())
            continue
        end
        self->state = 2
        sock.set_opt_no_delay(true)
        var last_request_time = runtime.time()
        var request_count = 0
        loop
            if ++request_count >= self->server->max_keep_alive
                log("Keep-alive exceeded max request count.")
                async_send(sock, compose_response(state_codes.code_408))
                break
            end
            # Read HTTP headers
            var header = new array
            var error_code = null
            state = new async.state
            loop
                async.read_until(sock, state, "\r\n")
                var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
                if timeout > 0 && !state.wait_for(timeout)
                    if state.has_done()
                        log("Read request header error: " + state.get_error())
                        error_code = state_codes.code_500
                    else
                        log("Read request header error: Keep-alive timeout.")
                        error_code = state_codes.code_408
                    end
                    break
                end
                var line = trim(state.get_result())
                if line.empty()
                    break
                end
                header.push_back(move(line))
            end
            if error_code == null && header.empty()
                log("Read request header error: Empty request.")
                error_code = state_codes.code_400
            end
            if error_code != null
                async_send(sock, compose_response(error_code))
                break
            end
            # Construct HTTP session
            var session = new http_session{sock, header}
            log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host)
            # Read POST data if needed
            var data = null
            if session.method == "POST"
                data = state.get_buffer(session.content_length)
                var remaining = session.content_length - data.size
                while remaining > 0
                    state = async.read(sock, remaining)
                    var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
                    if timeout > 0 && !state.wait_for(timeout)
                        if state.has_done()
                            log("Read POST body error: " + state.get_error())
                            error_code = state_codes.code_500
                        else
                            log("Read POST body error: Keep-alive timeout.")
                            error_code = state_codes.code_408
                        end
                        break
                    end
                    data.append(state.get_result())
                    remaining = session.content_length - data.size
                end
                if error_code != null
                    async_send(sock, compose_response(error_code))
                    break
                end
            else
                data = session.args
            end
            # Call handler
            link url_map = self->server->url_map
            if url_map.exist(session.url)
                url_map[session.url](*self->server, session, data)
            else if self->server->wwwroot_path != null
                var base_path = self->server->wwwroot_path
                var full_path = path_normalize(base_path + "/" + session.url)
                log("Resolved path: " + full_path)
                if full_path.find(base_path, 0) == 0
                    if system.path.is_directory(full_path)
                        if full_path[-1] != '/'
                            full_path.append('/')
                        end
                        full_path.append("index.html")
                        log("Directory request, try to serve: " + full_path)
                    end
                    if system.path.is_file(full_path) && system.file.can_read(full_path)
                        log("Serving file: " + full_path)
                        session.send_response(state_codes.code_200, self->server->read_file(full_path), get_mime(full_path))
                    else
                        if system.file.exist(full_path)
                            error_code = state_codes.code_403
                        else
                            error_code = state_codes.code_404
                        end
                    end
                else
                    error_code = state_codes.code_403
                end
            else
                error_code = state_codes.code_403
            end
            if error_code != null
                log("Resolving resource error: " + error_code)
                if url_map.exist(error_code)
                    url_map[error_code](*self->server, session, data)
                else
                    async_send(sock, compose_response(error_code))
                end
            end
            last_request_time = runtime.time()
            # Keep-Alive check
            if !sock.is_open() || session.version <= "1.0" || (session.connection != null && session.connection.tolower() == "close")
                break
            end
        end
        sock.close()
    end
end

# Public Interfaces

var proxy = null, timeout_ms = null, low_speed_limit = null

function http_get(url)
    var buff = new iostream.char_buff
    var session = curl.make_session_os(buff.get_ostream())
    session.set_url(url)
    session.allow_redirect(true)
    if proxy != null
        session.set_proxy(proxy)
    end
    session.set_ssl_verify_host(false)
    session.set_ssl_verify_peer(false)
    if timeout_ms != null
        session.set_connect_timeout_ms(timeout_ms)
        session.set_accept_timeout_ms(timeout_ms)
        session.set_low_speed_time(timeout_ms)
    end
    if low_speed_limit != null
        session.set_low_speed_limit(low_speed_limit)
    end
    if session.perform()
        return buff.get_string()
    else
        return null
    end
end

function http_post(url, post_fields)
    var buff = new iostream.char_buff
    var session = curl.make_session_os(buff.get_ostream())
    session.set_url(url)
    session.allow_redirect(true)
    if proxy != null
        session.set_proxy(proxy)
    end
    session.set_http_post(true)
    session.set_http_post_fields(post_fields)
    session.set_ssl_verify_host(false)
    session.set_ssl_verify_peer(false)
    if timeout_ms != null
        session.set_connect_timeout_ms(timeout_ms)
        session.set_accept_timeout_ms(timeout_ms)
        session.set_low_speed_time(timeout_ms)
    end
    if low_speed_limit != null
        session.set_low_speed_limit(low_speed_limit)
    end
    if session.perform()
        return buff.get_string()
    else
        return null
    end
end

function local_addr()
    var sock = new udp.socket
    sock.connect(udp.endpoint("8.8.8.8", 53))
    var addr = sock.local_endpoint().address()
    sock.close()
    return addr
end

class http_server
    var acceptor = null
    var async_guard = null
    var wwwroot_path = null
    var url_map = new hash_map
    var worker_list = null
    var worker_count = 4
    var max_keep_alive = 100
    var keep_alive_timeout = 5000
    var mtime_map = new hash_map
    var content_map = new hash_map
    # private functions
    function read_file(path)
        var time = runtime.time()
        if mtime_map.exist(path)
            var last_mtime = mtime_map[path]
            var current_mtime = system.file.mtime(path)
            if current_mtime == last_mtime && content_map.exist(path)
                return content_map[path]
            end
            mtime_map[path] = current_mtime
        else
            mtime_map.insert(path, system.file.mtime(path))
        end
        var data = global.read_file(path)
        content_map.insert(path, move(data))
        return data
    end
    function init()
        # Init workers
        async_guard = new async.work_guard
        worker_list = new array
        foreach it in range(worker_count)
            var worker = gcnew worker_type
            worker->server = &this
            worker->co = fiber.create(worker_main, worker)
            worker->co.resume()
            worker_list.push_back(worker)
        end
    end
    # public functions
    function set_wwwroot(path)
        if system.path.is_directory(path)
            wwwroot_path = path_normalize(path)
            if wwwroot_path[-1] == '/'
                wwwroot_path.cut(1)
            end
            log("Set wwwroot to: " + wwwroot_path)
        end
        return this
    end
    function set_config(conf)
        if conf.exist("worker_count")
            worker_count = conf["worker_count"] as integer
        end
        if conf.exist("max_keep_alive")
            max_keep_alive = conf["max_keep_alive"] as integer
        end
        if conf.exist("keep_alive_timeout")
            keep_alive_timeout = conf["keep_alive_timeout"] as integer
        end
        return this
    end
    function bind_page(url, path, state_code)
        var normalized_path = path_normalize((wwwroot_path != null ? wwwroot_path + "/" + path : path))
        url_map.insert(url, [normalized_path, state_code](server, session, post_data){
            session.send_response(state_code, server.read_file(normalized_path), get_mime(normalized_path))
        })
        return this
    end
    function bind_code(state_code, path)
        var normalized_path = path_normalize((wwwroot_path != null ? wwwroot_path + "/" + path : path))
        url_map.insert(state_code, [normalized_path, state_code](server, session, post_data){
            session.send_response(state_code, server.read_file(normalized_path), get_mime(normalized_path))
        })
        return this
    end
    function bind_func(url, func : function)
        url_map.insert(url, func)
        return this
    end
    function listen(port : integer)
        acceptor = tcp.acceptor(tcp.endpoint_v4(port))
        log("Listening on port: " + to_string(port))
        return this
    end
    function poll()
        if async_guard is null
            init()
        end
        foreach worker in worker_list
            worker->co.resume()
        end
    end
    function run()
        init()
        loop
            foreach worker in worker_list
                worker->co.resume()
            end
        end
    end
end
