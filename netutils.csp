# Generated by Extended CovScript Compiler
# DO NOT MODIFY
# Date: Fri Oct  3 14:14:55 2025
import ecs as netutils_ecs
struct __netutils_ecs_lambda_impl_1__
	var normalized_path = null
	var state_code = null
	function construct(_normalized_path, _state_code)
		this.normalized_path := _normalized_path
		this.state_code := _state_code
	end
	function call(server, session, post_data)
		link self = this.call
		session.send_response(state_code, server.read_file(normalized_path), get_mime(normalized_path))
	end
end
struct __netutils_ecs_lambda_impl_2__
	var normalized_path = null
	var state_code = null
	function construct(_normalized_path, _state_code)
		this.normalized_path := _normalized_path
		this.state_code := _state_code
	end
	function call(server, session, post_data)
		link self = this.call
		session.send_response(state_code, server.read_file(normalized_path), get_mime(normalized_path))
	end
end
package netutils
import network; using network
import regex
import curl
import codec.json as json
constant server_name = "CovScript-NetUtils"
constant server_version = "1.2.0"
var request_line_reg = regex.build("^([A-Z]+) ([^ ?]+)(?:\\?([^ ]*))? HTTP/([0-9.]+)$")
var request_header_reg = regex.build("^([^:]*): ?(.*)$")
namespace state_codes
	constant code_200 = "200 OK"
	constant code_400 = "400 Bad Request"
	constant code_403 = "403 Forbidden"
	constant code_404 = "404 Not Found"
	constant code_408 = "408 Request Timeout"
	constant code_500 = "500 Internal Server Error"
	constant code_503 = "503 Service Unavailable"
end
var wday_map = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}
var mon_map = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}
function time_padding(obj, width)
	var time = to_string(obj)
	var last = width - time.size
	if last <= 0
		return time
	end
	var str = new string
	foreach it in range(last) do str.append("0")
	return str + time
end
function compose_http_time()
	var tm = runtime.utc_time()
	return wday_map[tm.wday] + ", " + time_padding(tm.mday, 2) + " " + mon_map[tm.mon] + " " + to_string(1900 + tm.year) + " " + time_padding(tm.hour, 2) + ":" + time_padding(tm.min, 2) + ":" + time_padding(tm.sec, 2) + " GMT"
end
function compose_response(code)
	return "HTTP/1.1 " + code + "\r\n" + "Connection: close\r\n" + "Content-Length: 0\r\n\r\n"
end
var log_stream = null
function log(msg)
	if log_stream != null
		log_stream.println("[" + compose_http_time() + "]: " + msg)
	end
end
function send_content(sock, content)
	async.write(sock, to_fixed_hex(content.size) + content)
end
function receive_content(sock)
	var state = async.read(sock, 16)
	if !state.wait()
		log("Read content header failed: " + state.get_error())
		return null
	end
	var size = from_fixed_hex(state.get_result())
	state = async.read(sock, size)
	if !state.wait()
		log("Read content body failed: " + state.get_error())
		return null
	end
	return state.get_result()
end
function receive_content_s(sock, timeout)
	var state = async.read(sock, 16)
	var time = runtime.time()
	if !state.wait_for(timeout)
		if state.has_done()
			log("Read content header failed: " + state.get_error())
			return {state_codes.code_500, null}
		else
			log("Read content header failed: Timeout")
			return {state_codes.code_408, null}
		end
	end
	var size = from_fixed_hex(state.get_result())
	state = async.read(sock, size)
	var remain = timeout - (runtime.time() - time)
	if time > 0 && !state.wait_for(remain)
		if state.has_done()
			log("Read content body failed: " + state.get_error())
			return {state_codes.code_500, null}
		else
			log("Read content body failed: Timeout")
			return {state_codes.code_408, null}
		end
	end
	return {null, state.get_result()}
end
function read_file(path)
	var start_time = runtime.time()
	var ifs = iostream.fstream(path, iostream.openmode.bin_in)
	var data = new iostream.char_buff
	var ofs = data.get_ostream()
	loop
		var ch = ifs.get()
		if ifs.good() && !ifs.eof()
			ofs.put(ch)
		else
			break
		end
		if runtime.time() - start_time > 100
			fiber.yield()
			start_time = runtime.time()
		end
	end
	return data.get_string()
end
function path_normalize(path)
	if path == null || path.empty()
		return "."
	end
	var alt_sep = (system.path.separator == '/' ? '\\' : '/')
	var is_unc = false
	var is_abs = false
	var drive_letter = ""
	var norm_path = new string
	foreach ch in path
		if ch == alt_sep
			norm_path.append('/')
		else
			norm_path.append(ch)
		end
	end
	context.unlink_var("path")
	path = norm_path
	if system.path.separator == '\\'
		if path.find("//", 0) == 0
			is_unc = true
			path = path.substr(2, path.size - 2)
		else
			var m = regex.build("^([A-Za-z]:)").match(path)
			if !m.empty()
				drive_letter = m.str(1)
				path = path.substr(drive_letter.size, path.size - drive_letter.size)
				is_abs = true
			end
		end
		is_abs = is_abs or is_unc
	else
		if path.find("/", 0) == 0
			is_abs = true
		end
	end
	var components = path.split({'/'})
	var stack = new array
	foreach comp in components
		if comp.empty() or comp == "."
			continue
		end
		if comp == ".."
			if stack.size > 0 and stack.back != ".."
				stack.pop_back()
			else
				if !is_abs
					stack.push_back("..")
				end
			end
		else
			stack.push_back(comp)
		end
	end
	var result = new string
	if is_unc
		result = "//"
	else
		if drive_letter != ""
			result = drive_letter
		else
			if is_abs
				result = "/"
			end
		end
	end
	foreach comp in stack
		if !result.empty() and result[-1] != '/'
			result.append("/")
		end
		result.append(comp)
	end
	return result
end
var mime_map = netutils_ecs.type_constructor.__hash_map({".html" : "text/html", ".htm" : "text/html", ".txt" : "text/plain", ".js" : "application/javascript", ".css" : "text/css", ".png" : "image/png", ".jpg" : "image/jpeg", ".jpeg" : "image/jpeg", ".gif" : "image/gif", ".json" : "application/json"})
function get_mime(path)
	var pos = path.rfind(".", path.size - 1)
	if pos == -1
		return "application/octet-stream"
	end
	var ext = path.substr(pos, path.size - pos).tolower()
	if mime_map.exist(ext)
		return mime_map[ext]
	else
		return "application/octet-stream"
	end
end
class http_session
	var url = null
	var args = null
	var sock = null
	var host = null
	var method = null
	var version = null
	var connection = null
	var content_length = null
	var is_master = true
	function construct(socket, request_header)
		sock = socket
		var request_line = request_header.front
		request_header.pop_front()
		var match = request_line_reg.match(request_line)
		if !match.empty()
			method = match.str(1)
			url = match.str(2)
			args = match.str(3)
			version = match.str(4)
		else
			async.write(sock, compose_response(state_codes.code_400))
			return
		end
		if url.empty()
			url = "/"
		end
		foreach line in request_header
			var match = request_header_reg.match(line)
			if !match.empty()
				switch match.str(1).tolower()
					case "host"
						host = match.str(2)
					end
					case "connection"
						connection = match.str(2)
					end
					case "content-length"
						content_length = match.str(2).to_number()
					end
				end
			end
		end
	end
	function send_response(code, data, type)
		var conn = connection
		if conn == null || conn.empty()
			conn = (version <= "1.0" ? "close" : "keep-alive")
		end
		var content_len = to_string(data.size)
		var resp = new string
		resp.append("HTTP/" + version + " " + code + "\r\n")
		resp.append("Date: " + compose_http_time() + "\r\n")
		resp.append("Server: " + server_name + "/" + server_version + "\r\n")
		resp.append("Connection: " + conn + "\r\n")
		resp.append("Content-Length: " + content_len + "\r\n")
		resp.append("Content-Type: " + type + "\r\n")
		resp.append("\r\n")
		resp.append(data)
		if is_master
			async.write(sock, resp)
		else
			send_content(sock, resp)
		end
	end
	function serialize()
		return json.to_string(json.from_var(netutils_ecs.type_constructor.__hash_map({"url" : url, "args" : args, "host" : host, "method" : method, "version" : version, "connection" : connection, "content_length" : content_length})))
	end
	function deserialize(data)
		var obj = json.to_var(json.from_string(data))
		url = obj["url"]
		args = obj["args"]
		host = obj["host"]
		method = obj["method"]
		version = obj["version"]
		connection = obj["connection"]
		content_length = obj["content_length"]
		is_master = false
	end
end
struct worker_type
	var co = null
	var rank = 0
	var state = 0
	var server = null
end
function trim(str)
	var beg = 0
	var end = str.size - 1
	while beg <= end && (str[beg].isspace() || str[beg].iscntrl())
		++beg
	end
	while end >= beg && (str[end].isspace() || str[end].iscntrl())
		--end
	end
	if beg > end
		return ""
	end
	return str.substr(beg, end - beg + 1)
end
function worker_main(self)
	loop
		self->state = 1
		var sock = new tcp.socket
		var state = async.accept(sock, self->server->acceptor)
		if !state.wait()
			log("Accept error: " + state.get_error())
			continue
		end
		self->state = 2
		sock.set_opt_no_delay(true)
		var last_request_time = runtime.time()
		var request_count = 0
		loop
			if ++request_count >= self->server->max_keep_alive
				log("Keep-alive exceeded max request count.")
				async.write(sock, compose_response(state_codes.code_408))
				break
			end
			var header = new array
			var error_code = null
			state = new async.state
			loop
				async.read_until(sock, state, "\r\n")
				var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
				if timeout > 0 && !state.wait_for(timeout)
					if state.has_done()
						log("Read request header error: " + state.get_error())
						error_code = state_codes.code_500
					else
						log("Read request header error: Keep-alive timeout.")
						error_code = state_codes.code_408
					end
					break
				end
				var line = trim(state.get_result())
				if line.empty()
					break
				end
				header.push_back(move(line))
			end
			if error_code == null && header.empty()
				log("Read request header error: Empty request.")
				error_code = state_codes.code_400
			end
			if error_code != null
				async.write(sock, compose_response(error_code))
				break
			end
			var session = netutils_ecs.param_new(http_session, {sock, header})
			log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host)
			var data = null
			if session.method == "POST"
				data = state.get_buffer(session.content_length)
				var remaining = session.content_length - data.size
				while remaining > 0
					state = async.read(sock, remaining)
					var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
					if timeout > 0 && !state.wait_for(timeout)
						if state.has_done()
							log("Read POST body error: " + state.get_error())
							error_code = state_codes.code_500
						else
							log("Read POST body error: Keep-alive timeout.")
							error_code = state_codes.code_408
						end
						break
					end
					data.append(state.get_result())
					remaining = session.content_length - data.size
				end
				if error_code != null
					async.write(sock, compose_response(error_code))
					break
				end
			else
				data = session.args
			end
			link url_map = self->server->url_map
			if url_map.exist(session.url)
				url_map[session.url](*self->server, session, data)
			else
				if self->server->wwwroot_path != null
					var base_path = self->server->wwwroot_path
					var full_path = path_normalize(base_path + "/" + session.url)
					log("Resolved path: " + full_path)
					if full_path.find(base_path, 0) == 0
						if system.path.is_directory(full_path)
							if full_path[-1] != '/'
								full_path.append('/')
							end
							full_path.append("index.html")
							log("Directory request, try to serve: " + full_path)
						end
						if system.path.is_file(full_path) && system.file.can_read(full_path)
							log("Serving file: " + full_path)
							session.send_response(state_codes.code_200, self->server->read_file(full_path), get_mime(full_path))
						else
							if system.file.exist(full_path)
								error_code = state_codes.code_403
							else
								error_code = state_codes.code_404
							end
						end
					else
						error_code = state_codes.code_403
					end
				else
					error_code = state_codes.code_403
				end
			end
			if error_code != null
				log("Resolving resource error: " + error_code)
				if url_map.exist(error_code)
					url_map[error_code](*self->server, session, data)
				else
					async.write(sock, compose_response(error_code))
				end
			end
			last_request_time = runtime.time()
			if !sock.is_open() || session.version <= "1.0" || (session.connection != null && session.connection.tolower() == "close")
				break
			end
		end
		async.poll()
		sock.close()
	end
end
struct slave_node
	var last_conn_time = null
	var sock = null
	var rank = null
	var state = 0
end
function master_spwan_worker(self)
	self->state = 2
	loop
		var sock = new tcp.socket
		var state = async.accept(sock, self->server->master_acceptor)
		if !state.wait()
			log("Master accept error: " + state.get_error())
			continue
		end
		sock.set_opt_no_delay(true)
		sock.set_opt_keep_alive(true)
		var node = gcnew slave_node
		node->sock = sock
		if !self->server->deprecated_rank.empty()
			node->rank = self->server->deprecated_rank.front
			self->server->deprecated_rank.pop_front()
		else
			node->rank = self->server->slave_list.size
		end
		send_content(sock, "SERVER " + server_version)
		var header = receive_content(sock).split({' '})
		if header.size != 2 || header[0] != "WORKER" || header[1] != server_version
			log("Handshake stage 1 error: Invalid response: " + header)
			continue
		end
		send_content(sock, "RANK " + to_string(node->rank))
		var rank = receive_content(sock).split({' '})
		if rank.size != 2 || rank[0] != "RANK" || rank[1] != to_string(node->rank)
			log("Handshake stage 2 error: Invalid response: " + rank)
			continue
		end
		node->state = 1
		node->last_conn_time = runtime.time()
		self->server->slave_list.push_back(node)
		log("Worker connected: Rank = " + to_string(node->rank) + ", Total Workers = " + to_string(self->server->slave_list.size))
	end
end
function master_echo_worker(self)
	self->state = 2
	loop
		fiber.yield()
		link slist = self->server->slave_list
		if slist.empty()
			continue
		end
		for it = slist.begin, it != slist.end, null
			fiber.yield()
			link node = it.data
			if node->state == 3
				log("Worker error on rank " + node->rank)
				self->server->deprecated_rank.push_back(node->rank)
				it = slist.erase(it)
			end
			if runtime.time() - node->last_conn_time < 5000 || node->state == 2
				it.next()
				continue
			end
			node->state = 2
			send_content(node->sock, "ECHO")
			var (error_code, response) = receive_content_s(node->sock, 100)
			if error_code != null || response != "ECHO"
				log("Worker error on rank " + node->rank)
				self->server->deprecated_rank.push_back(node->rank)
				it = slist.erase(it)
			else
				log("Echo from worker rank = " + node->rank)
				node->last_conn_time = runtime.time()
				node->state = 1
				it.next()
			end
		end
	end
end
function master_accept_worker(self)
	loop
		self->state = 1
		var sock = new tcp.socket
		var state = async.accept(sock, self->server->acceptor)
		if !state.wait()
			log("Accept error: " + state.get_error())
			continue
		end
		self->state = 2
		sock.set_opt_no_delay(true)
		log("Accepting new request...")
		var last_request_time = runtime.time()
		var request_count = 0
		loop
			if ++request_count >= self->server->max_keep_alive
				log("Keep-alive exceeded max request count.")
				async.write(sock, compose_response(state_codes.code_408))
				break
			end
			var header = new array
			var error_code = null
			state = new async.state
			loop
				async.read_until(sock, state, "\r\n")
				var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
				if timeout > 0 && !state.wait_for(timeout)
					if state.has_done()
						log("Read request header error: " + state.get_error())
						error_code = state_codes.code_500
					else
						log("Read request header error: Keep-alive timeout.")
						error_code = state_codes.code_408
					end
					break
				end
				var line = trim(state.get_result())
				if line.empty()
					break
				end
				header.push_back(move(line))
			end
			if error_code == null && header.empty()
				log("Read request header error: Empty request.")
				error_code = state_codes.code_400
			end
			if error_code != null
				async.write(sock, compose_response(error_code))
				break
			end
			var session = netutils_ecs.param_new(http_session, {sock, header})
			log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host)
			var data = null
			if session.method == "POST"
				data = state.get_buffer(session.content_length)
				var remaining = session.content_length - data.size
				while remaining > 0
					state = async.read(sock, remaining)
					var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
					if timeout > 0 && !state.wait_for(timeout)
						if state.has_done()
							log("Read POST body error: " + state.get_error())
							error_code = state_codes.code_500
						else
							log("Read POST body error: Keep-alive timeout.")
							error_code = state_codes.code_408
						end
						break
					end
					data.append(state.get_result())
					remaining = session.content_length - data.size
				end
				if error_code != null
					async.write(sock, compose_response(error_code))
					break
				end
			else
				data = session.args
			end
			while self->server->slave_list.empty()
				log("No available worker, wait...")
				fiber.yield()
			end
			var session_data = session.serialize()
			var node = null
			loop
				foreach it in self->server->slave_list
					if it->state == 1
						node = it
						break
					end
				end
				if node == null
					log("No available worker, wait...")
					fiber.yield()
				else
					break
				end
			end
			log("Dispatching to worker rank " + to_string(node->rank))
			node->state = 2
			send_content(node->sock, session_data)
			if session.method == "POST"
				send_content(node->sock, data)
			end
			log("Request dispatched, waiting for response...")
			var response = null
			(error_code, response) = receive_content_s(node->sock, last_request_time + self->server->keep_alive_timeout - runtime.time())
			if error_code != null
				async.write(sock, compose_response(error_code))
				node->state = 3
				break
			end
			node->last_conn_time = runtime.time()
			node->state = 1
			log("Sending response to client...")
			async.write(sock, response)
			last_request_time = runtime.time()
			if !sock.is_open() || session.version <= "1.0" || (session.connection != null && session.connection.tolower() == "close")
				break
			end
		end
		async.poll()
		sock.close()
	end
end
function slave_worker(self)
	loop
		self->state = 1
		var sock = new tcp.socket
		var state = async.connect(sock, self->server->master_endpoint)
		if !state.wait()
			log("Slave connect error: " + state.get_error())
			runtime.delay(100)
			continue
		end
		sock.set_opt_no_delay(true)
		sock.set_opt_keep_alive(true)
		var header = receive_content(sock).split({' '})
		if header.size != 2 || header[0] != "SERVER" || header[1] != server_version
			log("Handshake error: Invalid response: " + header)
			continue
		end
		send_content(sock, "WORKER " + server_version)
		var rank = receive_content(sock).split({' '})
		if rank.size != 2 || rank[0] != "RANK"
			log("Handshake error: Invalid response: " + rank)
			continue
		end
		self->rank = netutils_ecs.type_constructor.__integer(rank[1])
		send_content(sock, "RANK " + rank[1])
		log("Slave handshake success, rank = " + to_string(self->rank))
		self->state = 2
		var error_code = null
		var last_request_time = runtime.time()
		loop
			var context = receive_content(sock)
			if context == null
				break
			end
			if context == "ECHO"
				send_content(sock, "ECHO")
				log("Rank " + self->rank + ": Echo from server")
				last_request_time = runtime.time()
				continue
			end
			var session = new http_session
			session.deserialize(context)
			session.sock = sock
			log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host)
			var data = null
			if session.method == "POST"
				data = receive_content(sock)
			else
				data = session.args
			end
			link url_map = self->server->url_map
			if url_map.exist(session.url)
				url_map[session.url](*self->server, session, data)
			else
				if self->server->wwwroot_path != null
					var base_path = self->server->wwwroot_path
					var full_path = path_normalize(base_path + "/" + session.url)
					log("Resolved path: " + full_path)
					if full_path.find(base_path, 0) == 0
						if system.path.is_directory(full_path)
							if full_path[-1] != '/'
								full_path.append('/')
							end
							full_path.append("index.html")
							log("Directory request, try to serve: " + full_path)
						end
						if system.path.is_file(full_path) && system.file.can_read(full_path)
							log("Serving file: " + full_path)
							session.send_response(state_codes.code_200, self->server->read_file(full_path), get_mime(full_path))
						else
							if system.file.exist(full_path)
								error_code = state_codes.code_403
							else
								error_code = state_codes.code_404
							end
						end
					else
						error_code = state_codes.code_403
					end
				else
					error_code = state_codes.code_403
				end
			end
			if error_code != null
				log("Resolving resource error: " + error_code)
				if url_map.exist(error_code)
					url_map[error_code](*self->server, session, data)
				else
					async.write(sock, compose_response(error_code))
				end
			end
			last_request_time = runtime.time()
		end
	end
end
var proxy = null, timeout_ms = null, low_speed_limit = null
function http_get(url)
	var buff = new iostream.char_buff
	var session = curl.make_session_os(buff.get_ostream())
	session.set_url(url)
	session.allow_redirect(true)
	if proxy != null
		session.set_proxy(proxy)
	end
	session.set_ssl_verify_host(false)
	session.set_ssl_verify_peer(false)
	if timeout_ms != null
		session.set_connect_timeout_ms(timeout_ms)
		session.set_accept_timeout_ms(timeout_ms)
		session.set_low_speed_time(timeout_ms)
	end
	if low_speed_limit != null
		session.set_low_speed_limit(low_speed_limit)
	end
	if session.perform()
		return buff.get_string()
	else
		return null
	end
end
function http_post(url, post_fields)
	var buff = new iostream.char_buff
	var session = curl.make_session_os(buff.get_ostream())
	session.set_url(url)
	session.allow_redirect(true)
	if proxy != null
		session.set_proxy(proxy)
	end
	session.set_http_post(true)
	session.set_http_post_fields(post_fields)
	session.set_ssl_verify_host(false)
	session.set_ssl_verify_peer(false)
	if timeout_ms != null
		session.set_connect_timeout_ms(timeout_ms)
		session.set_accept_timeout_ms(timeout_ms)
		session.set_low_speed_time(timeout_ms)
	end
	if low_speed_limit != null
		session.set_low_speed_limit(low_speed_limit)
	end
	if session.perform()
		return buff.get_string()
	else
		return null
	end
end
function local_addr()
	var sock = new udp.socket
	sock.connect(udp.endpoint("8.8.8.8", 53))
	var addr = sock.local_endpoint().address()
	sock.close()
	return addr
end
class http_server
	var acceptor = null
	var async_guard = null
	var wwwroot_path = null
	var url_map = new hash_map
	var worker_list = null
	var worker_count = 4
	var max_keep_alive = 100
	var keep_alive_timeout = 5000
	var mtime_map = new hash_map
	var content_map = new hash_map
	var multi_process = false
	var is_master = true
	var master_acceptor = null
	var slave_list = new array
	var deprecated_rank = new array
	var spwan_timeout = 100
	var slave_keep_alive_timeout = 100000
	var master_endpoint = null
	function read_file(path)
		var time = runtime.time()
		if mtime_map.exist(path)
			var last_mtime = mtime_map[path]
			var current_mtime = system.file.mtime(path)
			if current_mtime == last_mtime && content_map.exist(path)
				return content_map[path]
			end
			mtime_map[path] = current_mtime
		else
			mtime_map.insert(path, system.file.mtime(path))
		end
		var data = global.read_file(path)
		content_map.insert(path, move(data))
		return data
	end
	function add_worker(func)
		var worker = gcnew worker_type
		worker->server = &this
		worker->co = fiber.create(func, worker)
		worker->co.resume()
		worker_list.push_back(worker)
	end
	function init()
		async_guard = new async.work_guard
		worker_list = new array
		var worker_func = null
		if multi_process
			if is_master
				log("Running in multi-process mode as master.")
				worker_func = master_accept_worker
				add_worker(master_spwan_worker)
				add_worker(master_echo_worker)
			else
				log("Running in multi-process mode as slave.")
				worker_func = slave_worker
			end
		else
			log("Running in single-process mode.")
			worker_func = worker_main
		end
		foreach it in range(worker_count)
			add_worker(worker_func)
		end
	end
	function set_wwwroot(path)
		if system.path.is_directory(path)
			wwwroot_path = path_normalize(path)
			if wwwroot_path[-1] == '/'
				wwwroot_path.cut(1)
			end
			log("Set wwwroot to: " + wwwroot_path)
		end
		return this
	end
	function set_config(conf)
		if conf.exist("worker_count")
			worker_count = netutils_ecs.type_constructor.__integer(conf["worker_count"])
		end
		if conf.exist("max_keep_alive")
			max_keep_alive = netutils_ecs.type_constructor.__integer(conf["max_keep_alive"])
		end
		if conf.exist("keep_alive_timeout")
			keep_alive_timeout = netutils_ecs.type_constructor.__integer(conf["keep_alive_timeout"])
		end
		return this
	end
	function bind_page(url, path, state_code)
		var normalized_path = path_normalize((wwwroot_path != null ? wwwroot_path + "/" + path : path))
		url_map.insert(url, netutils_ecs.init_lambda(global.__netutils_ecs_lambda_impl_1__, normalized_path, state_code))
		return this
	end
	function bind_code(state_code, path)
		var normalized_path = path_normalize((wwwroot_path != null ? wwwroot_path + "/" + path : path))
		url_map.insert(state_code, netutils_ecs.init_lambda(global.__netutils_ecs_lambda_impl_2__, normalized_path, state_code))
		return this
	end
	function bind_func(url, func)
		netutils_ecs.check_type_s("func", func, netutils_ecs.type_validator.__function)
		url_map.insert(url, func)
		return this
	end
	function set_master(ip, port)
		multi_process = true
		is_master = true
		master_acceptor = tcp.acceptor(tcp.endpoint(ip, port))
		log("Set as master server, listening on port: " + to_string(port))
		return this
	end
	function set_slave(ip, port)
		multi_process = true
		is_master = false
		master_endpoint = tcp.endpoint(ip, port)
		log("Set as slave server, connecting to port: " + to_string(port))
		return this
	end
	function listen(port)
		netutils_ecs.check_type_s("port", port, netutils_ecs.type_validator.__integer)
		acceptor = tcp.acceptor(tcp.endpoint_v4(port))
		log("Listening on port: " + to_string(port))
		return this
	end
	function poll()
		if netutils_ecs.general_is(async_guard, null)
			init()
		end
		foreach worker in worker_list
			worker->co.resume()
		end
	end
	function run()
		init()
		loop
			foreach worker in worker_list
				worker->co.resume()
			end
		end
	end
end
