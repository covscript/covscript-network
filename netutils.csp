# Generated by Extended CovScript Compiler
# DO NOT MODIFY
# Date: Tue Sep 30 16:57:35 2025
import ecs as netutils_ecs
struct __netutils_ecs_lambda_impl_1__
	function construct()
	end
	function call(session, post_data)
		link self = this.call
		var response_data = "<html><head><meta charset=\"UTF-8\"></head><body><p>404 Not Found: " + session.url + "</p></body></html>"
		session.send_response(state_codes.code_404, response_data, "text/html")
	end
end
struct __netutils_ecs_lambda_impl_2__
	var response_data = null
	var state_code = null
	function construct(_response_data, _state_code)
		this.response_data := _response_data
		this.state_code := _state_code
	end
	function call(session, post_data)
		link self = this.call
		session.send_response(state_code, response_data, "text/html")
	end
end
package netutils
import network; using network
import regex
import curl
var request_line_reg = regex.build("^([A-Z]+) ([^ ?]+)(?:\\?([^ ]*))? HTTP/([0-9.]+)$")
var request_header_reg = regex.build("^([^:]*): ?(.*)$")
namespace state_codes
	constant code_200 = "200 OK"
	constant code_400 = "400 Bad Request"
	constant code_403 = "403 Forbidden"
	constant code_404 = "404 Not Found"
	constant code_408 = "408 Request Timeout"
	constant code_500 = "500 Internal Server Error"
	constant code_503 = "503 Service Unavailable"
end
var wday_map = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}
var mon_map = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}
function time_padding(obj, width)
	var time = to_string(obj)
	var last = width - time.size
	if last <= 0
		return time
	end
	var str = new string
	foreach it in range(last) do str.append("0")
	return str + time
end
function compose_http_time()
	var tm = runtime.utc_time()
	return wday_map[tm.wday] + ", " + time_padding(tm.mday, 2) + " " + mon_map[tm.mon] + " " + to_string(1900 + tm.year) + " " + time_padding(tm.hour, 2) + ":" + time_padding(tm.min, 2) + ":" + time_padding(tm.sec, 2) + " GMT"
end
function compose_response(code)
	return "HTTP/1.1 " + code + "\r\n" + "Connection: close\r\n" + "Content-Length: 0\r\n\r\n"
end
var log_stream = null
function log(msg)
	if log_stream != null
		log_stream.println("[" + compose_http_time() + "]: " + msg)
	end
end
function async_send(sock, resp)
	if !sock.is_open()
		return
	end
	var state = async.write(sock, resp)
	if !state.wait()
		log("Send error: " + state.get_error())
	end
end
class http_session
	var url = null
	var args = null
	var sock = null
	var host = null
	var method = null
	var version = null
	var connection = null
	var content_length = null
	function construct(socket, request_header)
		sock = socket
		var request_line = request_header.front
		request_header.pop_front()
		var match = request_line_reg.match(request_line)
		if !match.empty()
			method = match.str(1)
			url = match.str(2)
			args = match.str(3)
			version = match.str(4)
		else
			async_send(sock, compose_response(state_codes.code_400))
			return
		end
		if url.empty()
			url = "/"
		end
		foreach line in request_header
			var match = request_header_reg.match(line)
			if !match.empty()
				switch match.str(1)
					case "Host"
						host = match.str(2)
					end
					case "Connection"
						connection = match.str(2)
					end
					case "Content-Length"
						content_length = match.str(2).to_number()
					end
				end
			end
		end
	end
	function send_response(code, data, type)
		var conn = connection
		if conn == null || conn.empty()
			conn = "keep-alive"
		end
		var content_len = to_string(data.size)
		var resp = new string
		resp.append("HTTP/" + version + " " + code + "\r\n")
		resp.append("Date: " + compose_http_time() + "\r\n")
		resp.append("Server: CovScript-HTTP/1.0\r\n")
		resp.append("Connection: " + conn + "\r\n")
		resp.append("Content-Length: " + content_len + "\r\n")
		resp.append("Content-Type: " + type + "\r\n")
		resp.append("\r\n")
		resp.append(data)
		async_send(sock, resp)
	end
end
struct worker_type
	var co = null
	var state = 0
	var server = null
end
function wait_sock(sock, size)
	while sock.available() < size
		fiber.yield()
	end
end
function trim(str)
	var beg = 0
	var end = str.size - 1
	while beg <= end && str[beg].isspace()
		++beg
	end
	while end >= beg && str[end].isspace()
		--end
	end
	if beg > end
		return ""
	end
	return str.substr(beg, end - beg + 1)
end
function worker_main(self)
	loop
		self->state = 1
		var sock = new tcp.socket
		var state = async.accept(sock, self->server->acceptor)
		if !state.wait()
			log("Accept error: " + state.get_error())
			continue
		end
		log("Incoming connection from " + sock.remote_endpoint().address())
		self->state = 2
		sock.set_opt_no_delay(true)
		var last_request_time = runtime.time()
		var request_count = 0
		loop
			if ++request_count >= self->server->max_keep_alive
				log("Keep-alive exceeded max request count.")
				async_send(sock, compose_response(state_codes.code_408))
				break
			end
			var header = new array
			var error_code = null
			state = new async.state
			loop
				async.read_until(sock, state, "\r\n")
				var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
				if timeout > 0 && !state.wait_for(timeout)
					if state.has_done()
						log("Read request header error: " + state.get_error())
						error_code = state_codes.code_500
					else
						log("Read request header error: Keep-alive timeout.")
						error_code = state_codes.code_408
					end
					break
				end
				var line = trim(state.get_result())
				if line.empty()
					break
				end
				header.push_back(move(line))
			end
			if error_code == null && header.empty()
				error_code = state_codes.code_400
			end
			if error_code != null
				async_send(sock, compose_response(error_code))
				break
			end
			var session = netutils_ecs.param_new(http_session, {sock, header})
			log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host)
			var data = null
			if session.method == "POST"
				data = state.get_buffer()
				var remaining = session.content_length - data.size
				while remaining > 0
					state = async.read(sock, remaining)
					var timeout = last_request_time + self->server->keep_alive_timeout - runtime.time()
					if timeout > 0 && !state.wait_for(timeout)
						if state.has_done()
							log("Read POST body error: " + state.get_error())
							error_code = state_codes.code_500
						else
							log("Read POST body error: Keep-alive timeout.")
							error_code = state_codes.code_408
						end
						break
					end
					data.append(state.get_result())
					remaining = session.content_length - data.size
				end
				if error_code != null
					async_send(sock, compose_response(error_code))
					break
				end
			else
				data = session.args
			end
			link url_map = self->server->url_map
			if url_map.exist(session.url)
				url_map[session.url](session, data)
			else
				url_map["404"](session, data)
			end
			last_request_time = runtime.time()
			if !sock.is_open() || session.version == "HTTP/1.0" || (session.connection != null && session.connection.tolower() == "close")
				break
			end
		end
		log("Closing connection from " + sock.remote_endpoint().address())
		sock.close()
	end
end
function read_file(path)
	var ifs = iostream.ifstream(path)
	var data = new string
	loop
		var ch = ifs.get()
		if ifs.good() && !ifs.eof()
			data.append(ch)
		else
			break
		end
	end
	return move(data)
end
var proxy = null, timeout_ms = null, low_speed_limit = null
function http_get(url)
	var buff = new iostream.char_buff
	var session = curl.make_session_os(buff.get_ostream())
	session.set_url(url)
	session.allow_redirect(true)
	if proxy != null
		session.set_proxy(proxy)
	end
	session.set_ssl_verify_host(false)
	session.set_ssl_verify_peer(false)
	if timeout_ms != null
		session.set_connect_timeout_ms(timeout_ms)
		session.set_accept_timeout_ms(timeout_ms)
		session.set_low_speed_time(timeout_ms)
	end
	if low_speed_limit != null
		session.set_low_speed_limit(low_speed_limit)
	end
	if session.perform()
		return buff.get_string()
	else
		return null
	end
end
function http_post(url, post_fields)
	var buff = new iostream.char_buff
	var session = curl.make_session_os(buff.get_ostream())
	session.set_url(url)
	session.allow_redirect(true)
	if proxy != null
		session.set_proxy(proxy)
	end
	session.set_http_post(true)
	session.set_http_post_fields(post_fields)
	session.set_ssl_verify_host(false)
	session.set_ssl_verify_peer(false)
	if timeout_ms != null
		session.set_connect_timeout_ms(timeout_ms)
		session.set_accept_timeout_ms(timeout_ms)
		session.set_low_speed_time(timeout_ms)
	end
	if low_speed_limit != null
		session.set_low_speed_limit(low_speed_limit)
	end
	if session.perform()
		return buff.get_string()
	else
		return null
	end
end
function local_addr()
	var sock = new udp.socket
	sock.connect(udp.endpoint("8.8.8.8", 53))
	var addr = sock.local_endpoint().address()
	sock.close()
	return addr
end
class http_server
	var acceptor = null
	var async_guard = null
	var url_map = new hash_map
	var worker_list = new array
	var worker_count = 4
	var keep_alive_timeout = 5000
	var max_keep_alive = 100
	function initialize()
		url_map.insert("404", netutils_ecs.init_lambda(global.__netutils_ecs_lambda_impl_1__))
	end
	function bind_page(url, path, state_code)
		var response_data = read_file(path)
		url_map.insert(url, netutils_ecs.init_lambda(global.__netutils_ecs_lambda_impl_2__, response_data, state_code))
	end
	function bind_func(url, func)
		netutils_ecs.check_type_s("func", func, netutils_ecs.type_validator.__function)
		url_map.insert(url, func)
	end
	function listen(port)
		netutils_ecs.check_type_s("port", port, netutils_ecs.type_validator.__integer)
		acceptor = tcp.acceptor(tcp.endpoint_v4(port))
	end
	function init()
		async_guard = new async.work_guard
		foreach it in range(worker_count)
			var worker = gcnew worker_type
			worker->server = &this
			worker->co = fiber.create(worker_main, worker)
			worker->co.resume()
			worker_list.push_back(worker)
		end
	end
	function poll()
		if netutils_ecs.general_is(async_guard, null)
			init()
		end
		foreach worker in worker_list
			worker->co.resume()
		end
	end
	function run()
		init()
		loop
			foreach worker in worker_list
				worker->co.resume()
			end
		end
	end
end
