#$cSYM/1.0(./netutils.ecs):-,-,-,-,1104,1104,1104,1104,1104,1104,1104,1105,1104,1104,1111,1111,1111,1111,1111,1111,1111,1111,1111,1112,1111,1111,0,2,3,3,3,4,6,7,11,12,14,15,16,17,18,19,20,21,22,23,27,32,34,35,36,37,38,39,40,41,42,43,45,46,53,54,56,59,60,62,64,65,66,67,68,70,71,72,74,75,76,77,78,79,80,81,82,83,84,85,86,87,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,129,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,188,189,190,190,191,192,192,192,193,194,195,196,197,198,199,200,213,215,216,217,218,219,220,221,222,223,224,225,226,228,229,230,231,232,233,234,236,237,239,240,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,321,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,365,366,367,368,369,370,371,372,373,374,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,414,415,416,417,418,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,445,446,447,448,449,450,451,452,453,454,455,456,457,459,460,461,462,463,464,465,466,470,471,472,474,475,476,478,479,480,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,503,504,505,506,507,509,510,511,512,513,514,515,517,518,520,521,522,523,524,525,526,527,529,530,531,532,534,535,537,538,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,629,630,631,632,632,633,634,635,635,636,638,639,640,641,642,643,644,645,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,765,766,767,769,770,771,772,773,774,775,776,777,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,820,821,822,823,824,825,827,828,829,833,834,835,836,837,838,839,840,841,842,843,844,846,847,848,849,850,851,852,853,854,855,856,858,859,860,861,862,863,864,865,866,867,867,868,869,870,871,872,873,874,875,875,876,877,878,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,923,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,977,978,979,980,981,982,983,985,986,987,988,989,990,991,992,993,994,995,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1035,1036,1037,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1062,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1102,1102,1103,1106,1107,1108,1109,1109,1109,1110,1113,1114,1115,1116,1116,1116,1117,1118,1119,1120,1120,1121,1122,1123,1124,1125,1126,1127,1127,1127,1128,1129,1130,1131,1132,1133,1134,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155
package netutils

import codec.json.value as json_value
import network.*, regex, curl
import codec.json

constant server_name = "CovScript-NetUtils"
constant server_version = "1.2.0"

# Internal Functions

var request_line_reg = regex.build_optimize("^([A-Z]+) ([^ ?]+)(?:\\?([^ ]*))? HTTP/([0-9.]+)$")
var request_header_reg = regex.build_optimize("^([^:]*): ?(.*)$")

namespace state_codes
    constant code_200 = "200 OK"
    constant code_400 = "400 Bad Request"
    constant code_403 = "403 Forbidden"
    constant code_404 = "404 Not Found"
    constant code_408 = "408 Request Timeout"
    constant code_500 = "500 Internal Server Error"
    constant code_503 = "503 Service Unavailable"
    constant code_eof = "000 End of file"
end

var wday_map = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
}

var mon_map = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
}

function time_padding(obj, width)
    var time = to_string(obj)
    var last = width - time.size
    if last <= 0
        return time
    end
    var str = new string
    foreach it in range(last) do str.append("0")
    return str + time
end

function compose_http_time()
    var tm = runtime.utc_time()
    return wday_map[tm.wday] + ", " +
        time_padding(tm.mday, 2) + " " +
        mon_map[tm.mon] + " " +
        to_string(1900 + tm.year) + " " +
        time_padding(tm.hour, 2) + ":" +
        time_padding(tm.min, 2) + ":" +
        time_padding(tm.sec, 2) + " GMT"
end

function compose_response(code)
    return "HTTP/1.1 " + code + "\r\n" +
        "Connection: close\r\n" +
        "Content-Length: 0\r\n\r\n"
end

var log_stream = null

function log(msg)
    if log_stream != null
        log_stream.println("[" + compose_http_time() + "]: " + msg)
    end
end

function send_content(sock, content)
    async.write(sock, to_fixed_hex(content.size) + content)
end

function receive_content(sock)
    var state = async.read(sock, 16)
    if !state.wait()
        log("Read content header failed: " + state.get_error())
        return null
    end
    var size = from_fixed_hex(state.get_result())
    state = async.read(sock, size)
    if !state.wait()
        log("Read content body failed: " + state.get_error())
        return null
    end
    return state.get_result()
end

function receive_content_s(sock, timeout)
    var start_time = runtime.time()
    var state = async.read(sock, 16)
    if !state.wait_for(timeout)
        if state.has_done()
            log("Read content header failed: " + state.get_error())
            return {state_codes.code_500, null}
        else
            log("Read content header failed: Timeout")
            return {state_codes.code_408, null}
        end
    end
    var size = from_fixed_hex(state.get_result())
    state = async.read(sock, size)
    var remain = timeout - (runtime.time() - start_time)
    if remain <= 0
        log("Read content body failed: Timeout")
        return {state_codes.code_408, null}
    end
    if !state.wait_for(remain)
        if state.has_done()
            log("Read content body failed: " + state.get_error())
            return {state_codes.code_500, null}
        else
            log("Read content body failed: Timeout")
            return {state_codes.code_408, null}
        end
    end
    return {null, state.get_result()}
end

function read_file(path)
    var ifs = iostream.fstream(path, iostream.openmode.bin_in)
    var data = new string
    while ifs.good()
        data.append(ifs.read(8192))
    end
    return move(data)
end

var path_extractor = regex.build_optimize("^([A-Za-z]:)")

function path_normalize(path)
    if path == null || path.empty()
        return "."
    end
    var alt_sep = (system.path.separator == '/' ? '\\' : '/')
    var is_unc = false
    var is_abs = false
    var drive_letter = ""
    var norm_path = new string
    foreach ch in path
        if ch == alt_sep
            norm_path.append('/')
        else
            norm_path.append(ch)
        end
    end
    context.unlink_var("path")
    path = norm_path
    if system.path.separator == '\\'
        if path.find("//", 0) == 0  # UNC Path
            is_unc = true
            path = path.substr(2, path.size - 2)
        else
            var m = path_extractor.match(path)
            if !m.empty()
                drive_letter = m.str(1)
                path = path.substr(drive_letter.size, path.size - drive_letter.size)
                is_abs = true
            end
        end
        is_abs = is_abs or is_unc
    else
        if path.find("/", 0) == 0
            is_abs = true
        end
    end
    var components = path.split({'/'})
    var stack = new array
    foreach comp in components
        if comp.empty() or comp == "."
            continue
        end
        if comp == ".."
            if stack.size > 0 and stack.back != ".."
                stack.pop_back()
            else
                if !is_abs
                    stack.push_back("..")
                end
            end
        else
            stack.push_back(comp)
        end
    end
    var result = new string
    if is_unc
        result = "//"
    else if drive_letter != ""
        result = drive_letter
    else if is_abs
        result = "/"
    end
    foreach comp in stack
        if !result.empty() and result[-1] != '/'
            result.append("/")
        end
        result.append(comp)
    end
    return result
end

var mime_map = {
    ".html": "text/html",
    ".htm": "text/html",
    ".txt": "text/plain",
    ".js": "application/javascript",
    ".css": "text/css",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".json": "application/json"
} as hash_map

function get_mime(path)
    var pos = path.rfind(".", path.size - 1)
    if pos == -1
        return "application/octet-stream"
    end
    var ext = path.substr(pos, path.size - pos).tolower()
    if mime_map.exist(ext)
        return mime_map[ext]
    else
        return "application/octet-stream"
    end
end

class http_session
    var url = null
    var args = null
    var host = null
    var method = null
    var version = null
    var connection = null
    # POST data
    var post_data = null
    var content_length = null
    # for handler
    var sock = null
    var write_response = async.write
    # for multi-node setup
    var response = null
    function send_response(code, data, type)
        var content_len = to_string(data.size)
        var resp = new string
        resp.append("HTTP/" + version + " " + code + "\r\n")
        resp.append("Date: " + compose_http_time() + "\r\n")
        resp.append("Server: " + server_name + "/" + server_version + "\r\n")
        resp.append("Connection: " + connection + "\r\n")
        resp.append("Content-Length: " + content_len + "\r\n")
        resp.append("Content-Type: " + type + "\r\n")
        resp.append("\r\n")
        resp.append(data)
        write_response(sock, resp)
    end
    function serialize()
        var obj = json_value.make_object()
        obj.set_member("url", json_value.make_string(url))
        obj.set_member("args", json_value.make_string(args))
        obj.set_member("host", json_value.make_string(host))
        obj.set_member("method", json_value.make_string(method))
        obj.set_member("version", json_value.make_string(version))
        obj.set_member("connection", json_value.make_string(connection))
        if method == "POST"
            obj.set_member("content_length", json_value.make_int(content_length))
        end
        return json.to_string(obj)
    end
    function deserialize(data)
        var obj = json.from_string(data)
        url = obj.get_member("url").as_string()
        args = obj.get_member("args").as_string()
        host = obj.get_member("host").as_string()
        method = obj.get_member("method").as_string()
        version = obj.get_member("version").as_string()
        connection = obj.get_member("connection").as_string()
        if method == "POST"
            content_length = obj.get_member("content_length").as_int()
        end
        write_response = send_content
    end
end

function create_http_session(request_header)
    var session = new http_session
    var request_line = request_header.pop_front()
    var match = request_line_reg.match(request_line)
    if !match.empty()
        session.method = match.str(1)
        session.url = match.str(2)
        session.args = match.str(3)
        session.version = match.str(4)
    else
        return null
    end
    if session.url.empty()
        session.url = "/"
    end
    foreach line in request_header
        var match = request_header_reg.match(line)
        if !match.empty()
            switch match.str(1).tolower()
                case "host"
                    session.host = match.str(2)
                end
                case "connection"
                    session.connection = match.str(2).tolower()
                end
                case "content-length"
                    session.content_length = match.str(2) as integer
                end
            end
        end
    end
    if session.connection == null || session.connection.empty()
        session.connection = (session.version <= "1.0" ? "close" : "keep-alive")
    end
    return move(session)
end

function read_http_header(sock, keep_alive_timeout)
    # Read HTTP headers
    var header = new array
    var error_code = null
    var state = new async.state
    loop
        async.read_until(sock, state, "\r\n")
        var timeout = keep_alive_timeout - runtime.time()
        if timeout <= 0
            error_code = state_codes.code_408
            break
        end
        if !state.wait_for(timeout)
            if state.has_done()
                if state.eof()
                    log("Read request header: End of file")
                    error_code = state_codes.code_eof
                else
                    log("Read request header error: " + state.get_error())
                    error_code = state_codes.code_500
                end
            else
                log("Read request header error: Keep-alive timeout.")
                error_code = state_codes.code_408
            end
            break
        end
        var line = state.get_result().trim()
        if line.empty()
            break
        end
        header.push_back(move(line))
    end
    if error_code == null && header.empty()
        log("Read request header error: Empty request.")
        error_code = state_codes.code_400
    end
    if error_code != null
        if error_code != state_codes.code_eof
            async.write(sock, compose_response(error_code))
        end
        return null
    end
    # Construct HTTP session
    var session = create_http_session(header)
    if session == null
        log("Parse request header error.")
        async.write(sock, compose_response(state_codes.code_400))
        return null
    end
    log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host + ", Connection = " + session.connection)
    if session.connection == "keep-alive"
        sock.set_opt_keep_alive(true)
    end
    # Read POST data if needed
    if session.method == "POST"
        session.post_data = state.get_buffer(session.content_length)
        var remaining = session.content_length - session.post_data.size
        while remaining > 0
            state = async.read(sock, remaining)
            var timeout = keep_alive_timeout - runtime.time()
            if timeout <= 0
                error_code = state_codes.code_408
                break
            end
            if !state.wait_for(timeout)
                if state.has_done()
                    if state.eof()
                        log("Read POST body: End of file")
                        error_code = state_codes.code_eof
                    else
                        log("Read POST body error: " + state.get_error())
                        error_code = state_codes.code_500
                    end
                else
                    log("Read POST body error: Keep-alive timeout.")
                    error_code = state_codes.code_408
                end
                break
            end
            session.post_data.append(state.get_result())
            remaining = session.content_length - session.post_data.size
        end
        if error_code != null
            if error_code != state_codes.code_eof
                async.write(sock, compose_response(error_code))
            end
            return null
        end
    end
    return move(session)
end

function call_http_handler(session, server)
    var error_code = null
    if server->url_map.exist(session.url)
        server->url_map[session.url](*server, session)
    else if server->wwwroot_path != null
        var base_path = server->wwwroot_path
        var full_path = path_normalize(base_path + "/" + session.url)
        log("Resolved path: " + full_path)
        if full_path.find(base_path, 0) == 0
            if system.path.is_directory(full_path)
                if full_path[-1] != '/'
                    full_path.append('/')
                end
                full_path.append("index.html")
                log("Directory request, try to serve: " + full_path)
            end
            if system.path.is_file(full_path) && system.file.can_read(full_path)
                log("Serving file: " + full_path)
                session.send_response(state_codes.code_200, server->read_file(full_path), get_mime(full_path))
            else
                if system.file.exist(full_path)
                    error_code = state_codes.code_403
                else
                    error_code = state_codes.code_404
                end
            end
        else
            error_code = state_codes.code_403
        end
    else
        error_code = state_codes.code_403
    end
    if error_code != null
        log("Resolving resource error: " + error_code)
        if server->url_map.exist(error_code)
            server->url_map[error_code](*server, session)
        else
            async.write(sock, compose_response(error_code))
        end
        return false
    else
        return true
    end
end

function safe_shutdown(sock)
    if sock.is_open()
        while async.poll()
            fiber.yield()
        end
        sock.close()
    end
end

# Workers

struct worker_type
    var co = null
    var rank = 0
    # -1 = error, 0 = ready, 1 = wait, 2 = busy
    var state = 0
    var server = null
end

function simple_worker(self)
    loop
        self->state = 1
        # Accept new connection
        var sock = new tcp.socket
        var state = async.accept(sock, self->server->acceptor)
        if !state.wait()
            log("Accept error: " + state.get_error())
            continue
        end
        self->state = 2
        sock.set_opt_no_delay(true)
        var last_request_time = runtime.time()
        var request_count = 0
        loop
            if ++request_count >= self->server->max_keep_alive
                log("Keep-alive exceeded max request count.")
                async.write(sock, compose_response(state_codes.code_408))
                break
            end
            var session = read_http_header(sock, last_request_time + self->server->keep_alive_timeout)
            if session == null
                break
            end
            # Call handler
            session.sock = sock
            if !call_http_handler(session, self->server)
                break
            end
            last_request_time = runtime.time()
            # Keep-Alive check
            if !sock.is_open() || session.connection == "close"
                break
            end
        end
        safe_shutdown(sock)
    end
end

struct http_conn
    var sock = null
    # -1 = close, 0 = established, 1 = busy
    var state = 0
    var close = false
    var keep_alive = true
    var request_count = 0
    var last_request_time = 0
    var request_idx = 0
    var request_queue = new array
end

struct slave_node
    var last_conn_time = null
    var sock = null
    var rank = null
    # -1 = error, 0 = ready, 1 = busy
    var state = 0
end

function master_spawn_worker(self)
    loop
        # Accept new connection
        log("Accepting new worker...")
        var sock = new tcp.socket
        var state = async.accept(sock, self->server->master_acceptor)
        if !state.wait()
            log("Master accept error: " + state.get_error())
            continue
        end
        sock.set_opt_no_delay(true)
        sock.set_opt_keep_alive(true)
        var node = gcnew slave_node
        node->sock = sock
        if !self->server->deprecated_rank.empty()
            node->rank = self->server->deprecated_rank.pop_front()
        else
            node->rank = self->server->slave_list.size
        end
        log("Starting handshake with worker rank " + node->rank)
        # Start handshake
        var rank_str = to_string(node->rank)
        send_content(sock, {"SERVER", server_version, rank_str}.join(" "))
        var error_code = null, response = null
        (error_code, response) = receive_content_s(sock, self->server->slave_spawn_timeout)
        if error_code != null
            log("Handshake timeout or error.")
            continue
        end
        var header = response.split({' '})
        if header.size != 3 || header[0] != "WORKER" || header[1] != server_version || header[2] != rank_str
            log("Handshake error: Invalid response: " + header)
            continue
        end
        node->last_conn_time = runtime.time()
        self->server->slave_list.push_back(node)
        log("Worker rank " + to_string(node->rank) + " connected, total workers = " + to_string(self->server->slave_list.size))
    end
end

function master_accept_worker(self)
    loop
        if self->server->conn_list.size >= self->server->max_connections
            fiber.yield()
            continue
        end
        log("Accepting new HTTP request..")
        var sock = new tcp.socket
        var state = async.accept(sock, self->server->acceptor)
        if !state.wait()
            log("Accept error: " + state.get_error())
            continue
        end
        sock.set_opt_no_delay(true)
        var conn = gcnew http_conn
        conn->sock = sock
        conn->last_request_time = runtime.time()
        self->server->conn_list.push_back(conn)
    end
end

function master_request_worker(self)
    link clist = self->server->conn_list
    loop
        var conn = null
        for it = clist.begin, it != clist.end, null
            var c = it.data
            if c->state == -1 || !c->sock.is_open()
                it = clist.erase(it)
                continue
            end
            if c->state == 0 && c->keep_alive
                clist.erase(it)
                clist.push_back(c)
                conn = c
                break
            end
            it.next()
        end
        if conn == null
            fiber.yield()
            continue
        end
        conn->state = 1
        var sock = conn->sock
        var session = read_http_header(sock, conn->last_request_time + self->server->keep_alive_timeout)
        if session == null
            safe_shutdown(sock)
            conn->state = -1
            continue
        end
        # Check keep-alive
        if runtime.time() - conn->last_request_time >= self->server->keep_alive_timeout
            log("Keep-alive exceeded timeout limit.")
            conn->keep_alive = false
        else if ++conn->request_count >= self->server->max_keep_alive
            log("Keep-alive exceeded max request count.")
            conn->keep_alive = false
        end
        conn->last_request_time = runtime.time()
        # Check connection type
        if session.connection == "close"
            conn->keep_alive = false
            conn->close = true
        end
        conn->request_queue.push_back(move(session))
        conn->state = 0
    end
end

function master_response_worker(self)
    link clist = self->server->conn_list
    loop
        if clist.empty()
            fiber.yield()
            continue
        end
        var conn = null
        foreach it in clist
            if !it->request_queue.empty()
                conn = it
                break
            end
        end
        if conn == null
            fiber.yield()
            continue
        end
        while !conn->request_queue.empty()
            link session = conn->request_queue.front
            if session != null && session.response != null
                async.write(conn->sock, session.response)
                conn->request_queue.pop_front()
                --conn->request_idx
            else
                fiber.yield()
                break
            end
        end
        if conn->request_queue.empty() && !conn->keep_alive
            if !conn->close
                async.write(conn->sock, compose_response(state_codes.code_408))
            end
            safe_shutdown(conn->sock)
            conn->state = -1
        end
    end
end

function master_dispatch_worker(self)
    link slist = self->server->slave_list
    loop
        var node = null
        for it = slist.begin, it != slist.end, null
            var n = it.data
            if n->state == -1
                self->server->deprecated_rank.push_back(n->rank)
                it = slist.erase(it)
                continue
            end
            if n->state == 0
                slist.erase(it)
                slist.push_back(n)
                node = n
                break
            else
                it.next()
            end
        end
        if node == null
            log("Waiting for available slave worker")
            runtime.delay(100)
            fiber.yield()
            continue
        end
        var conn = null
        foreach it in self->server->conn_list
            if it->request_idx < it->request_queue.size
                conn = it
                break
            end
        end
        var timeout = node->last_conn_time + self->server->slave_keep_alive_timeout - runtime.time()
        if timeout <= 0
            timeout = self->server->slave_keep_alive_timeout
        end
        if conn == null
            # Departure queue empty, send heartbeat
            if runtime.time() - node->last_conn_time >= self->server->heartbeat_interval
                node->state = 1
                send_content(node->sock, "SLAVE_HEALTH_QUERY")
                var (error_code, response) = receive_content_s(node->sock, timeout)
                if error_code == null && response == "SLAVE_HEALTH_CONFIRM"
                    log("Heartbeat success for worker rank " + node->rank)
                    node->last_conn_time = runtime.time()
                    node->state = 0
                else
                    log("Heartbeat failed for worker rank " + node->rank)
                    safe_shutdown(node->sock)
                    node->state = -1  
                end
            end
        else
            # Departure queue not empty, send request
            node->state = 1
            link session = conn->request_queue[conn->request_idx++]
            send_content(node->sock, session.serialize())
            if session.method == "POST"
                async.write(node->sock, session.post_data)
            end
            log("Request dispatched to worker rank " + node->rank + ", waiting for response...")
            var (error_code, response) = receive_content_s(node->sock, timeout)
            if error_code == null
                log("Read response success for worker rank " + node->rank)
                session.response = response
                node->last_conn_time = runtime.time()
                node->state = 0
            else
                log("Read response failed for worker rank " + node->rank)
                session.response = compose_response(error_code)
                safe_shutdown(node->sock)
                node->state = -1
            end
        end
        fiber.yield()
    end
end

function slave_worker(self)
    loop
        self->state = 1
        # Connect to master
        var sock = new tcp.socket
        var state = async.connect(sock, self->server->master_endpoint)
        if !state.wait()
            log("Slave connect error: " + state.get_error())
            runtime.delay(100)
            continue
        end
        sock.set_opt_no_delay(true)
        sock.set_opt_keep_alive(true)
        # Start handshake
        var header = receive_content(sock).split({' '})
        if header.size != 3 || header[0] != "SERVER" || header[1] != server_version
            log("Handshake error: Invalid response: " + header)
            continue
        end
        self->rank = header[2] as integer
        send_content(sock, {"WORKER", server_version, header[2]}.join(" "))
        log("Slave handshake success, rank = " + to_string(self->rank))
        self->state = 2
        var last_request_time = runtime.time()
        loop
            var timeout = last_request_time + self->server->slave_keep_alive_timeout - runtime.time()
            if timeout <= 0
                break
            end
            var (error_code, data) = receive_content_s(sock, timeout)
            if error_code != null
                break
            end
            if data == "SLAVE_HEALTH_QUERY"
                send_content(sock, "SLAVE_HEALTH_CONFIRM")
                log("Rank " + self->rank + ": Heartbeat from server")
                last_request_time = runtime.time()
                continue
            end
            var session = new http_session
            session.deserialize(data)
            if session.method == "POST"
                timeout = last_request_time + self->server->slave_keep_alive_timeout - runtime.time()
                if timeout <= 0
                    break
                end
                var state = async.read(sock, session.content_length)
                if !state.wait_for(timeout)
                    log("Error when receiving POST data")
                    break
                end
                session.post_data = state.get_result()
            end
            log("Received: Method = " + session.method + ", URL = " + session.url + ", Host = " + session.host)
            # Call handler
            session.sock = sock
            if !call_http_handler(session, self->server)
                continue
            end
            last_request_time = runtime.time()
        end
        # delay before error recovery
        runtime.delay(100)
    end
end

# Public Interfaces

function hex_char_to_int(c)
    if c >= "0" && c <= "9"
        return to_integer(c[0]) - to_integer('0')
    end
    if c >= "a" && c <= "f"
        return to_integer(c[0]) - to_integer('a') + 10
    end
    if c >= "A" && c <= "F"
        return to_integer(c[0]) - to_integer('A') + 10
    end
    return -1
end

function hex_to_int(s)
    var val = 0
    foreach i in range(s.size)
        var d = hex_char_to_int(s.substr(i, 1))
        if d < 0
            return 0
        end
        val = val * 16 + d
    end
    return val
end

function url_decode(s)
    var out = ""
    var i = 0
    var n = s.size
    while i < n
        var ch = s.substr(i, 1)
        if ch == "+"
            out += " "
            i += 1
        else if ch == "%" && i + 2 < n
            var hx = s.substr(i + 1, 2)
            var byte = hex_to_int(hx)
            out += char.from_ascii(byte)
            i += 3
        else
            out += ch
            i += 1
        end
    end
    return out
end

function parse_http_args(input)
    var qs = input
    var qpos = input.find("?", 0)
    if qpos != -1
        qs = input.substr(qpos + 1, input.size)
    end
    var result = new hash_map
    if qs == "" || qs == null
        return result
    end
    var parts = qs.split({'&'})
    foreach p in parts
        if p == ""
            continue
        end
        var eq = p.find("=", 0)
        var key = ""
        var val = ""
        if eq == -1
            key = url_decode(p)
            val = ""
        else
            key = url_decode(p.substr(0, eq))
            val = url_decode(p.substr(eq + 1, p.size))
        end
        if !result.exist(key)
            result[key] = val
        else
            var cur = result[key]
            if typeid cur != typeid array
                var v = new array
                v.push_back(cur)
                v.push_back(val)
                result[key] = v
            else
                cur.push_back(val)
                result[key] = cur
            end
        end
    end
    return result
end

var proxy = null, timeout_ms = null, low_speed_limit = null

function http_get(url)
    var buff = new iostream.char_buff
    var session = curl.make_session_os(buff.get_ostream())
    session.set_url(url)
    session.allow_redirect(true)
    if proxy != null
        session.set_proxy(proxy)
    end
    session.set_ssl_verify_host(false)
    session.set_ssl_verify_peer(false)
    if timeout_ms != null
        session.set_connect_timeout_ms(timeout_ms)
        session.set_accept_timeout_ms(timeout_ms)
        session.set_low_speed_time(timeout_ms)
    end
    if low_speed_limit != null
        session.set_low_speed_limit(low_speed_limit)
    end
    if runtime.await(session.perform)
        return buff.get_string()
    else
        return null
    end
end

function http_post(url, post_fields)
    var buff = new iostream.char_buff
    var session = curl.make_session_os(buff.get_ostream())
    session.set_url(url)
    session.allow_redirect(true)
    if proxy != null
        session.set_proxy(proxy)
    end
    session.set_http_post(true)
    session.set_http_post_fields(post_fields)
    session.set_ssl_verify_host(false)
    session.set_ssl_verify_peer(false)
    if timeout_ms != null
        session.set_connect_timeout_ms(timeout_ms)
        session.set_accept_timeout_ms(timeout_ms)
        session.set_low_speed_time(timeout_ms)
    end
    if low_speed_limit != null
        session.set_low_speed_limit(low_speed_limit)
    end
    if runtime.await(session.perform)
        return buff.get_string()
    else
        return null
    end
end

function local_addr()
    var sock = new udp.socket
    sock.connect(udp.endpoint("8.8.8.8", 53))
    var addr = sock.local_endpoint().address()
    sock.close()
    return addr
end

class http_server
    var acceptor = null
    var async_guard = null
    var wwwroot_path = null
    var url_map = new hash_map
    var worker_list = null
    var worker_count = 4
    var max_keep_alive = 100
    var keep_alive_timeout = 5000
    var mtime_map = new hash_map
    var content_map = new hash_map
    # multi-process support
    var multi_process = false
    var is_master = true
    var master_worker_count = 4
    var master_acceptor = null
    var conn_list = new list
    var slave_list = new list
    var deprecated_rank = new list
    var max_connections = 100
    var heartbeat_interval = 1000
    var slave_spawn_timeout = 1000
    var slave_keep_alive_timeout = 5000
    var master_endpoint = null
    # private functions
    function read_file(path)
        var time = runtime.time()
        if mtime_map.exist(path)
            var last_mtime = mtime_map[path]
            var current_mtime = system.file.mtime(path)
            if current_mtime == last_mtime && content_map.exist(path)
                return content_map[path]
            end
            mtime_map[path] = current_mtime
        else
            mtime_map.insert(path, system.file.mtime(path))
        end
        var data = global.read_file(path)
        content_map.insert(path, data)
        return data
    end
    function add_worker(func)
        var worker = gcnew worker_type
        worker->server = &this
        worker->co = fiber.create(func, worker)
        worker->co.resume()
        worker_list.push_back(worker)
    end
    function init()
        # Init workers
        async_guard = new async.work_guard
        worker_list = new array
        var worker_func = null
        # Init multi-process
        if multi_process
            if is_master
                log("Running in multi-process mode as master.")
                worker_func = master_dispatch_worker
                add_worker(master_spawn_worker)
                add_worker(master_accept_worker)
                foreach it in range(master_worker_count)
                    add_worker(master_request_worker)
                end
                add_worker(master_response_worker)
            else
                log("Running in multi-process mode as slave.")
                worker_func = slave_worker
            end
        else
            log("Running in single-process mode.")
            worker_func = simple_worker
        end
        foreach it in range(worker_count)
            add_worker(worker_func)
        end
    end
    # public functions
    function set_wwwroot(path : string)
        if system.path.is_directory(path)
            wwwroot_path = path_normalize(path)
            if wwwroot_path[-1] == '/'
                wwwroot_path.cut(1)
            end
            log("Set wwwroot to: " + wwwroot_path)
        end
        return this
    end
    function set_config(conf : hash_map)
        if conf.exist("wwwroot")
            set_wwwroot(conf["wwwroot"])
        end
        if conf.exist("worker_count")
            worker_count = conf["worker_count"] as integer
        end
        if conf.exist("max_keep_alive")
            max_keep_alive = conf["max_keep_alive"] as integer
        end
        if conf.exist("keep_alive_timeout")
            keep_alive_timeout = conf["keep_alive_timeout"] as integer
        end
        if conf.exist("master_worker_count")
            master_worker_count = conf["master_worker_count"] as integer
        end
        if conf.exist("max_connections")
            max_connections = conf["max_connections"] as integer
        end
        if conf.exist("heartbeat_interval")
            heartbeat_interval = conf["heartbeat_interval"] as integer
        end
        if conf.exist("slave_spawn_timeout")
            slave_spawn_timeout = conf["slave_spawn_timeout"] as integer
        end
        if conf.exist("slave_keep_alive_timeout")
            slave_keep_alive_timeout = conf["slave_keep_alive_timeout"] as integer
        end
        return this
    end
    function bind_page(url : string, path : string)
        var normalized_path = path_normalize((wwwroot_path != null ? wwwroot_path + "/" + path : path))
        url_map.insert(url, [normalized_path](server, session){
            session.send_response(state_codes.code_200, server.read_file(normalized_path), get_mime(normalized_path))
        })
        return this
    end
    function bind_code(state_code : string, path : string)
        var normalized_path = path_normalize((wwwroot_path != null ? wwwroot_path + "/" + path : path))
        url_map.insert(state_code, [normalized_path, state_code](server, session){
            session.send_response(state_code, server.read_file(normalized_path), get_mime(normalized_path))
        })
        return this
    end
    function bind_func(url : string, func : function)
        url_map.insert(url, func)
        return this
    end
    function set_master(port : integer)
        multi_process = true
        is_master = true
        master_acceptor = tcp.acceptor(tcp.endpoint_v4(port))
        log("Set as master server, listening on port: " + to_string(port))
        return this
    end
    function set_slave(ip : string, port : integer)
        multi_process = true
        is_master = false
        master_endpoint = tcp.endpoint(ip, port)
        log("Set as slave worker, connecting to " + ip + ":" + to_string(port))
        return this
    end
    function listen(port : integer)
        acceptor = tcp.acceptor(tcp.endpoint_v4(port))
        log("Listening on port: " + to_string(port))
        return this
    end
    function poll()
        if async_guard is null
            init()
        end
        foreach worker in worker_list
            worker->co.resume()
        end
    end
    function run()
        init()
        loop
            foreach worker in worker_list
                worker->co.resume()
            end
        end
    end
end

